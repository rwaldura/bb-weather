<html>
  <head>
	<meta charset="UTF-8" />
	
    <script type="text/javascript" src="weather.js"></script>	
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>

    <script type="text/javascript">
/****************************************************************************/
function showError(message)
{
	console.log("*** ERROR " + message);
	const e = document.getElementById('chart_errors');
	e.textContent = message;
}

function clearError()
{
	const e = document.getElementById('chart_errors');
	e.textContent = '';
}

function debug(dt)
{
	const t = new google.visualization.Table(document.getElementById('data_debug'));
	t.draw(dt, { showRowNumber: true });
}

/***************************************************************************
 * Style the datapoint to indicate wind direction.
 * See https://developers.google.com/chart/interactive/docs/points#customizing-individual-points
 */
function dir2style(dt, row, col, period /* minutes */)
{
	const dir = dt.getValue(row, col);
	const color = dir2color(dir);
	return `point { 
		shape-type: star;
		shape-sides: 2;
		shape-rotation: ${dir}; 
		fill-color: ${color} }`;
}

/***************************************************************************
 * See https://developers.google.com/chart/interactive/docs/reference#dateformat
 */
function formatTimestamp(ts /* Unix timestamp */, period /* minutes */)
{
	const date = new Date(ts * 1000);

	var format;
	if (period < 60) // show minutes
		format = "h:mm aa";
	else // show day of week and hour
		format = "EEE MMM d, h aa";

	const f = new google.visualization.DateFormat({ pattern: format });
	return f.formatValue(date);
}

/****************************************************************************/
function formatSpeed(P, T /* minutes */)
{
	var V = wind_speed(P, T * 60); // in canonical unit
	V = G.speed.convert(V); // to current unit
	return G.speed.format(V);
}

/***************************************************************************
 * Custom tooltip
 * See https://developers.google.com/chart/interactive/docs/customizing_tooltip_content#customizing-html-content
 */
function tooltip(dt, row, ts_col, dir_col, revs_col, period /* minutes */)
{
	const tstamp = formatTimestamp(dt.getValue(row, ts_col), period);
	const dir = formatDirection(dt.getValue(row, dir_col));
	const speed = formatSpeed(dt.getValue(row, revs_col), period);
	return `<div class="tooltip">
		<span class="timestamp">${tstamp}</span><br>
		${dir}<br> 
		${speed}
		</div>`;
}

/****************************************************************************/
function windSpeed(dt, row, col, T)
{
	const P = dt.getValue(row, col);
	const V = wind_speed(P, T);
	return G.speed.convert(V);
}

/***************************************************************************
 */
// data is defined as:
//
// column index 0
// id: "tstamp",
// type: "number"
// 
// column index 1
// id: "period",
// type: "number"
// 
// column index 2
// id: "direction",
// type: "number"
// 
// column index 3
// id: "revs",
// type: "number"		
function groupWindData(dt, lookback, period)
{
	lookback *= 60;	// to seconds
	period *= 60;	// to seconds
	
	var view = new google.visualization.DataView(dt);

	// WHERE period=1 AND tstamp > 1 day ago
	view.setRows( view.getFilteredRows( [
		{ column: 1, value: 1 },
		{ column: 0, minValue: view.getColumnRange(0).max - lookback } ]));

	if (period > 1 * 60) // further grouping is necessary
	{
		// quantize into time windows of "period" seconds
		// see https://developers.google.com/chart/interactive/docs/reference#group 
		const grouped = google.visualization.data.group(
			view,
			// group by timestamp over the period given
			[{ column: 0,
				modifier: function(t) { return period * Math.floor(t / period) }, 
				type: 'number' }],
			// aggregate columns: MIN(period), AVG(dir), SUM(revs)
			// MIN(period) isn't actually used, it's there merely to preserve column indices
			[ { column: 1,
				aggregation: google.visualization.data.min, 
				type: 'number' },
			{ column: 2,
				aggregation: google.visualization.data.avg, 
				type: 'number' },
			{ column: 3, 
				aggregation: google.visualization.data.sum, 
				type: 'number' } ]);
			
		view = new google.visualization.DataView(grouped);
	}

	view.setColumns([
		{ id: 'date_time', // timestamp, as a Date object
			type: 'datetime', 
			calc: function(dt, row) { const t = dt.getValue(row, 0); return new Date(t * 1000) } }, 
		{ id: 'speed_mph', 
			label: "Wind Speed",
			type: 'number', 
			calc: function(dt, row) { return windSpeed(dt, row, 3 /* revs */, period) } }, 
		{ id: 'point_style', 
			role: 'style',
			type: 'string', 
			calc: function(dt, row) { return dir2style(dt, row, 2 /* dir */, period / 60) } },
		{ id: 'point_tooltip', 
			role: 'tooltip', 
			properties: { html: true },
			type: 'string', 
			calc: function(dt, row) { return tooltip(dt, row, 0, 2, 3, period / 60) } } ]);

	return view;
}

/****************************************************************************/
function drawCharts(dt /* datatable */)
{
	if (dt)
	{
		G.currentDataTable = dt;
	} 
	else 
	{
		dt = G.currentDataTable;
	}
	
	const opts = {
		legend: 'none',
		colors: ['#cccccc'], 
		backgroundColor: G.bgColor,
		chartArea: { left: 40, top: 30, width: '95%' },
		lineWidth: 0,
		pointsVisible: true,
		pointSize: 18,
		fontName: "Google Sans",
		tooltip: { isHtml: true },
		vAxis: { minValue: 0 } };								

	opts.title = 'Last 20 minutes';
	chart1.draw(
		groupWindData(dt, 20 /* 20 minutes */, 1 /* minute */), 
		opts);

	opts.title = 'Last Day';
	chart2.draw(
		groupWindData(dt, 26 * 60 /* ~1 day */, 60 /* minutes */), 
		opts);

	opts.title = 'Last Week';
	chart3.draw(
		groupWindData(dt, 7 * 24 * 60 /* 1 week */, 2 * 60 /* 2 hours */), 
		opts);	
}

/****************************************************************************/
function loadDataAndUpdateCharts(json)
{
	try
	{
		clearError();
		drawCharts(new google.visualization.DataTable(json));
	}
	catch (e)
	{
		showError("Drawing charts: " + e + " " + e.message);
	}	
}

/****************************************************************************/
// convert miles per hour...
const MPH_KMH = 1.609344;	// ... to kilometers per hour
const MPH_MS = 2.2352;		// ... to meters per second
const MPH_KNOTS = 0.868976;	// ... to knots

const UNITS_OF_MEASUREMENT = {
	"mph":   { format: function(v) { return Math.round(v) + " MPH"   }, convert: function(v) { return v             } },
	"kmh":   { format: function(v) { return Math.round(v) + " km/h"  }, convert: function(v) { return v * MPH_KMH   } },
	"ms":    { format: function(v) { return  v.toFixed(1) + " m/s"   }, convert: function(v) { return v / MPH_MS    } },
	"knots": { format: function(v) { return Math.round(v) + " knots" }, convert: function(v) { return v * MPH_KNOTS } },

	"C": { format: function(t) { return t + "&deg;C" }, convert: function(t) { return t } },
	"F": { format: function(t) { return t + "&deg;F" }, convert: function(t) { return 32 + (t * 9/5) } },
};

function parseSearchParameters()
{
	const params = new URLSearchParams(window.location.search);
	
	const g = {
		bgColor: (params.get("colors") === "muted") ? "#C9B091" : "white",
		speed: UNITS_OF_MEASUREMENT[ params.get("speed") || "mph" ],
		temp:  UNITS_OF_MEASUREMENT[ params.get("temp")  || "F"   ],
	};

	return g;
}

/***************************************************************************
 * Event handler for unit selector dropdown menu.
 */
function changeSpeedUnit(speedUnit)
{
	G.speed = UNITS_OF_MEASUREMENT[speedUnit];
	drawCharts();
}

/***************************************************************************
 * main()
 */
// global settings 
const G = parseSearchParameters();

const xhr = new XMLHttpRequest();
xhr.responseType = "json";
xhr.onerror = function(e) {
	showError("Loading chart data: " + e.message);
};
xhr.onload = function() {
	if (xhr.status == 200 // HTTP OK
		&& xhr.response) // JSON parsed successfully
	{
		loadDataAndUpdateCharts(xhr.response);
	}
	else
	{
		showError("Loading chart data: status=" + xhr.status + " resp=" + xhr.response);
	}
};

function refreshCharts()
{
	xhr.open("GET", "getDataTable.json", true);
	xhr.send();
	// next, the onload handler gets called
}

// refresh charts every minute
setInterval(refreshCharts, 66666 /* ms */);

google.charts.load('current', { 'packages': ['corechart','table'] });
var chart1, chart2, chart3;
google.charts.setOnLoadCallback(function () {
	chart1 = new google.visualization.AreaChart(
		document.getElementById('chart_speed_last_hour'));
	chart2 = new google.visualization.AreaChart(
		document.getElementById('chart_speed_last_day'));
	chart3 = new google.visualization.AreaChart(
		document.getElementById('chart_speed_last_week'));

	refreshCharts();
});	
    </script>
	<style>
	    body, div, td, select {
			border: 0;
	        margin: 0;
			padding: 0;
			font-family: "Google Sans";
	    }
		.tooltip {
			padding: 5;
			font-size: 14;
		}
		.tooltip .timestamp {
			font-weight: bold;
		}
		.tooltip .alt_units {
			font-size: 10;
		}	
		#chart_errors {
			font-size: 20;
			color: red;
			text-align: center;
		}	
	</style>
  </head>
  <body bgcolor="white">
	<div id="chart_errors">Loading... Please wait</div>
	<!-- sized to fit on 720p screen: 1280x720 -->
	<table>
		<tr>
			<td><div id="chart_speed_last_hour" style="width: 640; height: 360;"></div></td>
			<td><div id="chart_speed_last_day" style="width: 640; height: 360;"></div></td>
    	</tr>
		<tr>
			<td colspan="2"><div id="chart_speed_last_week" style="width: 1280; height: 360;"></div></td>
		</tr>
	</table>
	<div id="unit_selector">
		<select id="speed_unit" name="speed" onchange="changeSpeedUnit(this.value)">
			<option value="mph">Miles per hour</option>
			<option value="kmh">Kilometers per hour</option>
			<option value="ms">Meters per second</option>
			<option value="knots">Knots</option>
		</select>
	</div>				
	<div id="data_debug"></div>
  </body>
</html>
